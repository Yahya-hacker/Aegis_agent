"""
Advanced Vulnerability Analyzer for Aegis AI
Provides intelligent vulnerability analysis and prioritization
"""

import logging
from typing import Dict, List, Any, Tuple
from collections import defaultdict
import json

logger = logging.getLogger(__name__)


class VulnerabilityAnalyzer:
    """
    Advanced vulnerability analyzer with severity scoring and prioritization
    """
    
    # CVSS-like severity mapping
    SEVERITY_SCORES = {
        'critical': 10.0,
        'high': 8.0,
        'medium': 5.0,
        'low': 3.0,
        'info': 1.0
    }
    
    # Exploitability factors
    EXPLOITABILITY_FACTORS = {
        'network': 1.0,      # Remotely exploitable
        'adjacent': 0.8,     # Adjacent network access required
        'local': 0.5,        # Local access required
        'physical': 0.2      # Physical access required
    }
    
    # Impact factors
    IMPACT_FACTORS = {
        'complete': 1.0,     # Total compromise
        'high': 0.75,        # Significant impact
        'partial': 0.5,      # Limited impact
        'none': 0.0          # No impact
    }
    
    def __init__(self):
        self.vulnerability_database = {}
        self.prioritization_rules = self._load_prioritization_rules()
    
    def _load_prioritization_rules(self) -> Dict:
        """Load prioritization rules for different vulnerability types"""
        return {
            'sql_injection': {
                'base_severity': 'critical',
                'tags': ['injection', 'data_breach', 'authentication_bypass'],
                'exploitability': 'network',
                'impact': 'complete'
            },
            'xss': {
                'base_severity': 'high',
                'tags': ['injection', 'session_hijacking'],
                'exploitability': 'network',
                'impact': 'high'
            },
            'rce': {
                'base_severity': 'critical',
                'tags': ['code_execution', 'system_compromise'],
                'exploitability': 'network',
                'impact': 'complete'
            },
            'ssrf': {
                'base_severity': 'high',
                'tags': ['internal_access', 'information_disclosure'],
                'exploitability': 'network',
                'impact': 'high'
            },
            'idor': {
                'base_severity': 'medium',
                'tags': ['authorization', 'information_disclosure'],
                'exploitability': 'network',
                'impact': 'partial'
            },
            'path_traversal': {
                'base_severity': 'high',
                'tags': ['file_access', 'information_disclosure'],
                'exploitability': 'network',
                'impact': 'high'
            },
            'csrf': {
                'base_severity': 'medium',
                'tags': ['authentication', 'state_change'],
                'exploitability': 'network',
                'impact': 'partial'
            },
            'xxe': {
                'base_severity': 'high',
                'tags': ['injection', 'information_disclosure'],
                'exploitability': 'network',
                'impact': 'high'
            }
        }
    
    def analyze_finding(self, finding: Dict) -> Dict[str, Any]:
        """
        Analyze a finding and provide comprehensive assessment
        
        Args:
            finding: Dictionary with vulnerability information
                - type: Vulnerability type
                - url: Target URL
                - description: Description
                - evidence: Proof/evidence
                
        Returns:
            Enhanced finding with analysis results
        """
        vuln_type = finding.get('type', 'unknown').lower()
        
        # Get base information from rules
        rules = self.prioritization_rules.get(vuln_type, {
            'base_severity': 'info',
            'tags': [],
            'exploitability': 'network',
            'impact': 'none'
        })
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(
            rules['base_severity'],
            rules['exploitability'],
            rules['impact']
        )
        
        # Determine priority
        priority = self._determine_priority(risk_score, rules['tags'])
        
        # Generate remediation advice
        remediation = self._get_remediation_advice(vuln_type)
        
        # Enhanced finding
        enhanced = {
            **finding,
            'analysis': {
                'severity': rules['base_severity'],
                'risk_score': risk_score,
                'priority': priority,
                'exploitability': rules['exploitability'],
                'impact': rules['impact'],
                'tags': rules['tags'],
                'cvss_vector': self._generate_cvss_vector(rules)
            },
            'remediation': remediation,
            'references': self._get_references(vuln_type)
        }
        
        return enhanced
    
    def _calculate_risk_score(self, severity: str, exploitability: str, impact: str) -> float:
        """
        Calculate risk score (0-10 scale)
        
        Formula: Base Severity × Exploitability Factor × Impact Factor
        """
        base = self.SEVERITY_SCORES.get(severity, 1.0)
        exploit_factor = self.EXPLOITABILITY_FACTORS.get(exploitability, 1.0)
        impact_factor = self.IMPACT_FACTORS.get(impact, 0.5)
        
        score = base * exploit_factor * impact_factor
        return round(score, 2)
    
    def _determine_priority(self, risk_score: float, tags: List[str]) -> str:
        """Determine priority based on risk score and tags"""
        # High priority tags
        high_priority_tags = {'code_execution', 'authentication_bypass', 'system_compromise', 'data_breach'}
        
        if risk_score >= 9.0 or any(tag in high_priority_tags for tag in tags):
            return 'P0-Critical'
        elif risk_score >= 7.0:
            return 'P1-High'
        elif risk_score >= 4.0:
            return 'P2-Medium'
        elif risk_score >= 2.0:
            return 'P3-Low'
        else:
            return 'P4-Info'
    
    def _generate_cvss_vector(self, rules: Dict) -> str:
        """Generate simplified CVSS vector string"""
        exploit_map = {
            'network': 'N',
            'adjacent': 'A',
            'local': 'L',
            'physical': 'P'
        }
        
        impact_map = {
            'complete': 'C',
            'high': 'H',
            'partial': 'P',
            'none': 'N'
        }
        
        av = exploit_map.get(rules.get('exploitability', 'network'), 'N')
        impact = impact_map.get(rules.get('impact', 'none'), 'N')
        
        return f"CVSS:3.1/AV:{av}/AC:L/PR:N/UI:N/S:U/C:{impact}/I:{impact}/A:{impact}"
    
    def _get_remediation_advice(self, vuln_type: str) -> str:
        """Get specific remediation advice for vulnerability type"""
        remediation_map = {
            'sql_injection': 'Use parameterized queries/prepared statements. Never concatenate user input into SQL queries. Implement input validation and sanitization.',
            'xss': 'Implement context-aware output encoding. Use Content Security Policy (CSP). Sanitize user input. Use HTTPOnly and Secure flags on cookies.',
            'rce': 'Avoid executing system commands with user input. Use allowlists for permitted values. Implement strict input validation. Update vulnerable components.',
            'ssrf': 'Validate and sanitize URLs. Use allowlists for permitted domains. Implement network segmentation. Disable unnecessary URL schemas.',
            'idor': 'Implement proper authorization checks. Use indirect object references. Validate user permissions for each request.',
            'path_traversal': 'Use allowlists for file paths. Canonicalize file paths. Implement proper access controls. Avoid using user input in file operations.',
            'csrf': 'Implement anti-CSRF tokens. Use SameSite cookie attribute. Verify Origin/Referer headers. Re-authenticate for sensitive actions.',
            'xxe': 'Disable external entity processing in XML parsers. Use less complex data formats (JSON). Update XML parsing libraries.'
        }
        
        return remediation_map.get(vuln_type, 'Review security best practices for this vulnerability type. Consult OWASP guidelines.')
    
    def _get_references(self, vuln_type: str) -> List[str]:
        """Get reference links for vulnerability type"""
        base_owasp = "https://owasp.org/www-community/vulnerabilities/"
        
        reference_map = {
            'sql_injection': [
                f"{base_owasp}SQL_Injection",
                "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
            ],
            'xss': [
                f"{base_owasp}xss/",
                "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
            ],
            'rce': [
                "https://owasp.org/www-community/attacks/Command_Injection",
                "https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html"
            ],
            'ssrf': [
                "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery",
                "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
            ],
            'csrf': [
                "https://owasp.org/www-community/attacks/csrf",
                "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html"
            ]
        }
        
        return reference_map.get(vuln_type, ["https://owasp.org/www-project-top-ten/"])
    
    def prioritize_findings(self, findings: List[Dict]) -> List[Dict]:
        """
        Prioritize a list of findings by risk score
        
        Args:
            findings: List of vulnerability findings
            
        Returns:
            Sorted list with highest priority first
        """
        analyzed_findings = []
        
        for finding in findings:
            analyzed = self.analyze_finding(finding)
            analyzed_findings.append(analyzed)
        
        # Sort by risk score (descending)
        analyzed_findings.sort(
            key=lambda x: x['analysis']['risk_score'],
            reverse=True
        )
        
        return analyzed_findings
    
    def generate_report(self, findings: List[Dict]) -> str:
        """
        Generate a comprehensive vulnerability report
        
        Args:
            findings: List of analyzed findings
            
        Returns:
            Markdown formatted report
        """
        if not findings:
            return "No vulnerabilities found."
        
        # Analyze all findings
        analyzed = self.prioritize_findings(findings)
        
        # Generate statistics
        severity_counts = defaultdict(int)
        for finding in analyzed:
            severity = finding['analysis']['severity']
            severity_counts[severity] += 1
        
        # Build report
        report = ["# Vulnerability Assessment Report\n"]
        report.append(f"**Total Findings:** {len(analyzed)}\n")
        
        report.append("\n## Summary by Severity")
        for severity in ['critical', 'high', 'medium', 'low', 'info']:
            count = severity_counts.get(severity, 0)
            if count > 0:
                report.append(f"- **{severity.upper()}:** {count}")
        
        report.append("\n## Detailed Findings\n")
        
        for idx, finding in enumerate(analyzed, 1):
            analysis = finding['analysis']
            
            report.append(f"### {idx}. {finding.get('type', 'Unknown').upper()}")
            report.append(f"**Priority:** {analysis['priority']}")
            report.append(f"**Risk Score:** {analysis['risk_score']}/10")
            report.append(f"**Severity:** {analysis['severity'].upper()}")
            report.append(f"\n**Location:** {finding.get('url', 'Unknown')}")
            report.append(f"\n**Description:** {finding.get('description', 'No description')}")
            
            if finding.get('evidence'):
                report.append(f"\n**Evidence:**\n```\n{finding['evidence']}\n```")
            
            report.append(f"\n**Remediation:**\n{finding['remediation']}")
            
            report.append(f"\n**Tags:** {', '.join(analysis['tags'])}")
            report.append(f"\n**CVSS Vector:** `{analysis['cvss_vector']}`")
            
            report.append(f"\n**References:**")
            for ref in finding['references']:
                report.append(f"- {ref}")
            
            report.append("\n---\n")
        
        return "\n".join(report)
    
    def get_statistics(self, findings: List[Dict]) -> Dict[str, Any]:
        """Get statistics about findings"""
        if not findings:
            return {
                'total': 0,
                'by_severity': {},
                'by_priority': {},
                'average_risk_score': 0.0
            }
        
        analyzed = [self.analyze_finding(f) for f in findings]
        
        severity_counts = defaultdict(int)
        priority_counts = defaultdict(int)
        total_risk = 0.0
        
        for finding in analyzed:
            analysis = finding['analysis']
            severity_counts[analysis['severity']] += 1
            priority_counts[analysis['priority']] += 1
            total_risk += analysis['risk_score']
        
        return {
            'total': len(analyzed),
            'by_severity': dict(severity_counts),
            'by_priority': dict(priority_counts),
            'average_risk_score': round(total_risk / len(analyzed), 2),
            'highest_risk': max(f['analysis']['risk_score'] for f in analyzed),
            'lowest_risk': min(f['analysis']['risk_score'] for f in analyzed)
        }


# Singleton instance
_analyzer_instance = None

def get_vulnerability_analyzer() -> VulnerabilityAnalyzer:
    """Get singleton vulnerability analyzer instance"""
    global _analyzer_instance
    if _analyzer_instance is None:
        _analyzer_instance = VulnerabilityAnalyzer()
    return _analyzer_instance

{
  "tools": [
    {
      "tool_name": "genesis_fuzz_api",
      "binary_name": "python",
      "description": "Evolutionary genetic mutation fuzzer for API endpoints. Uses byte-level mutations, differential response analysis, and technology fingerprinting to discover zero-day vulnerabilities. Recommended for REST/GraphQL/JSON endpoints.",
      "intrusive": true,
      "category": "zero_day_discovery",
      "priority": 1,
      "use_case": "API endpoints, REST APIs, GraphQL, JSON endpoints",
      "args_schema": {
        "url": {
          "type": "string",
          "required": true,
          "description": "Target API endpoint URL"
        },
        "method": {
          "type": "string",
          "required": false,
          "description": "HTTP method (default: POST)"
        },
        "base_payload": {
          "type": "object",
          "required": false,
          "description": "Base payload to mutate (e.g., {\"username\": \"admin\", \"password\": \"test\"})"
        },
        "grammar": {
          "type": "object",
          "required": false,
          "description": "Protocol grammar definition for smart mutations"
        }
      },
      "json_prompt_template": "{\"tool\": \"genesis_fuzz_api\", \"args\": {\"url\": \"<API_URL>\", \"method\": \"POST\", \"base_payload\": {}}}"
    },
    {
      "tool_name": "subdomain_enumeration",
      "binary_name": "subfinder",
      "description": "Find subdomains using passive sources",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "domain": {
          "type": "string",
          "required": true,
          "description": "Target domain to enumerate"
        }
      },
      "json_prompt_template": "{\"tool\": \"subdomain_enumeration\", \"args\": {\"domain\": \"<DOMAIN>\"}}"
    },
    {
      "tool_name": "port_scanning",
      "binary_name": "naabu",
      "description": "Fast port scanner to discover open ports",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target host or IP"
        }
      },
      "json_prompt_template": "{\"tool\": \"port_scanning\", \"args\": {\"target\": \"<TARGET>\"}}"
    },
    {
      "tool_name": "nmap_scan",
      "binary_name": "nmap",
      "description": "Detailed network scan with service detection",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target host or IP"
        },
        "ports": {
          "type": "string",
          "required": false,
          "description": "Comma-separated port list (default: 80,443,8080,8443)"
        }
      },
      "json_prompt_template": "{\"tool\": \"nmap_scan\", \"args\": {\"target\": \"<TARGET>\", \"ports\": \"<PORTS>\"}}"
    },
    {
      "tool_name": "url_discovery",
      "binary_name": "gau",
      "description": "Discover URLs and endpoints from archives",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "domain": {
          "type": "string",
          "required": true,
          "description": "Target domain"
        }
      },
      "json_prompt_template": "{\"tool\": \"url_discovery\", \"args\": {\"domain\": \"<DOMAIN>\"}}"
    },
    {
      "tool_name": "tech_detection",
      "binary_name": "python",
      "description": "Detect web technologies and frameworks",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target URL"
        }
      },
      "json_prompt_template": "{\"tool\": \"tech_detection\", \"args\": {\"target\": \"<TARGET>\"}}"
    },
    {
      "tool_name": "vulnerability_scan",
      "binary_name": "nuclei",
      "description": "Fast vulnerability scanner using templates",
      "intrusive": true,
      "category": "vulnerability_assessment",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target URL to scan"
        }
      },
      "json_prompt_template": "{\"tool\": \"vulnerability_scan\", \"args\": {\"target\": \"<TARGET>\"}}"
    },
    {
      "tool_name": "run_sqlmap",
      "binary_name": "sqlmap",
      "description": "SQL injection detection and exploitation",
      "intrusive": true,
      "category": "exploitation",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target URL with parameter"
        }
      },
      "json_prompt_template": "{\"tool\": \"run_sqlmap\", \"args\": {\"target\": \"<TARGET>\"}}"
    },
    {
      "tool_name": "discover_interactables",
      "binary_name": "python",
      "description": "Use Selenium to find forms and interactive elements",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target URL"
        }
      },
      "json_prompt_template": "{\"tool\": \"discover_interactables\", \"args\": {\"target\": \"<TARGET>\"}}"
    },
    {
      "tool_name": "test_form_payload",
      "binary_name": "python",
      "description": "Test form inputs with payloads (XSS, SQLi, etc.)",
      "intrusive": true,
      "category": "exploitation",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target URL with form"
        },
        "form_identifier": {
          "type": "string",
          "required": true,
          "description": "Form ID or XPath selector"
        },
        "input_payloads": {
          "type": "object",
          "required": true,
          "description": "Dictionary of field names to payload values"
        }
      },
      "json_prompt_template": "{\"tool\": \"test_form_payload\", \"args\": {\"target\": \"<TARGET>\", \"form_identifier\": \"<FORM_ID>\", \"input_payloads\": {\"<FIELD_NAME>\": \"<PAYLOAD>\"}}}"
    },
    {
      "tool_name": "fetch_url",
      "binary_name": "python",
      "description": "Fetch and analyze a specific URL",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target URL to fetch"
        }
      },
      "json_prompt_template": "{\"tool\": \"fetch_url\", \"args\": {\"target\": \"<TARGET>\"}}"
    },
    {
      "tool_name": "manage_session",
      "binary_name": "python",
      "description": "Manage authenticated sessions (login/logout)",
      "intrusive": false,
      "category": "session_management",
      "args_schema": {
        "action": {
          "type": "string",
          "required": true,
          "description": "Action: 'login' or 'logout'"
        },
        "credentials": {
          "type": "object",
          "required": false,
          "description": "Login credentials (required for login action)"
        }
      },
      "json_prompt_template": "{\"tool\": \"manage_session\", \"args\": {\"action\": \"<ACTION>\", \"credentials\": {\"url\": \"<LOGIN_URL>\", \"username_field\": \"<USERNAME_SELECTOR>\", \"password_field\": \"<PASSWORD_SELECTOR>\", \"username\": \"<USERNAME>\", \"password\": \"<PASSWORD>\"}}}"
    },
    {
      "tool_name": "db_add_finding",
      "binary_name": "python",
      "description": "Add a security finding to mission database",
      "intrusive": false,
      "category": "database",
      "args_schema": {
        "type": {
          "type": "string",
          "required": true,
          "description": "Finding type (e.g., XSS, SQLi, IDOR)"
        },
        "url": {
          "type": "string",
          "required": true,
          "description": "URL where finding was discovered"
        },
        "severity": {
          "type": "string",
          "required": true,
          "description": "Severity: critical, high, medium, low, info"
        },
        "description": {
          "type": "string",
          "required": false,
          "description": "Detailed description"
        },
        "evidence": {
          "type": "string",
          "required": false,
          "description": "Evidence or proof"
        }
      },
      "json_prompt_template": "{\"tool\": \"db_add_finding\", \"args\": {\"type\": \"<TYPE>\", \"url\": \"<URL>\", \"severity\": \"<SEVERITY>\", \"description\": \"<DESCRIPTION>\", \"evidence\": \"<EVIDENCE>\"}}"
    },
    {
      "tool_name": "db_get_findings",
      "binary_name": "python",
      "description": "Retrieve findings from mission database",
      "intrusive": false,
      "category": "database",
      "args_schema": {
        "severity": {
          "type": "string",
          "required": false,
          "description": "Filter by severity"
        },
        "verified": {
          "type": "boolean",
          "required": false,
          "description": "Filter by verification status"
        }
      },
      "json_prompt_template": "{\"tool\": \"db_get_findings\", \"args\": {\"severity\": \"<SEVERITY>\", \"verified\": <VERIFIED>}}"
    },
    {
      "tool_name": "db_is_scanned",
      "binary_name": "python",
      "description": "Check if a target was already scanned",
      "intrusive": false,
      "category": "database",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target to check"
        },
        "scan_type": {
          "type": "string",
          "required": false,
          "description": "Specific scan type to check"
        }
      },
      "json_prompt_template": "{\"tool\": \"db_is_scanned\", \"args\": {\"target\": \"<TARGET>\", \"scan_type\": \"<SCAN_TYPE>\"}}"
    },
    {
      "tool_name": "db_mark_scanned",
      "binary_name": "python",
      "description": "Mark a target as scanned to avoid duplication",
      "intrusive": false,
      "category": "database",
      "args_schema": {
        "target": {
          "type": "string",
          "required": true,
          "description": "Target that was scanned"
        },
        "scan_type": {
          "type": "string",
          "required": true,
          "description": "Type of scan performed"
        },
        "result": {
          "type": "string",
          "required": false,
          "description": "Summary of scan results"
        }
      },
      "json_prompt_template": "{\"tool\": \"db_mark_scanned\", \"args\": {\"target\": \"<TARGET>\", \"scan_type\": \"<SCAN_TYPE>\", \"result\": \"<RESULT>\"}}"
    },
    {
      "tool_name": "db_get_statistics",
      "binary_name": "python",
      "description": "Get mission statistics from database",
      "intrusive": false,
      "category": "database",
      "args_schema": {},
      "json_prompt_template": "{\"tool\": \"db_get_statistics\", \"args\": {}}"
    },
    {
      "tool_name": "finish_mission",
      "binary_name": "internal",
      "description": "Complete the current mission",
      "intrusive": false,
      "category": "control",
      "args_schema": {
        "reason": {
          "type": "string",
          "required": true,
          "description": "Reason for finishing"
        }
      },
      "json_prompt_template": "{\"tool\": \"finish_mission\", \"args\": {\"reason\": \"<REASON>\"}}"
    },
    {
      "tool_name": "ask_user_for_approval",
      "binary_name": "internal",
      "description": "Ask user for guidance or approval",
      "intrusive": false,
      "category": "control",
      "args_schema": {
        "message": {
          "type": "string",
          "required": true,
          "description": "Message to show to user"
        }
      },
      "json_prompt_template": "{\"tool\": \"ask_user_for_approval\", \"args\": {\"message\": \"<MESSAGE>\"}}"
    },
    {
      "tool_name": "application_spider.crawl_and_map_application",
      "binary_name": "python",
      "description": "Cognitive web application crawler with 3 levels: 'fast' (HTML parsing), 'static_js' (JS analysis), 'deep_visual' (AI-powered screenshot analysis)",
      "intrusive": false,
      "category": "reconnaissance",
      "args_schema": {
        "base_url": {
          "type": "string",
          "required": true,
          "description": "Base URL of the application to crawl"
        },
        "mode": {
          "type": "string",
          "required": false,
          "description": "Crawling mode: 'fast', 'static_js', or 'deep_visual' (default: 'fast')"
        }
      },
      "json_prompt_template": "{\"tool\": \"application_spider.crawl_and_map_application\", \"args\": {\"base_url\": \"<URL>\", \"mode\": \"fast\"}}"
    },
    {
      "tool_name": "logic_tester.test_logic_flow",
      "binary_name": "python",
      "description": "Test business logic flows for vulnerabilities like sequence bypasses, state manipulation, and business rule violations",
      "intrusive": true,
      "category": "exploitation",
      "args_schema": {
        "flow_name": {
          "type": "string",
          "required": true,
          "description": "Name of the logic flow being tested"
        },
        "steps": {
          "type": "array",
          "required": true,
          "description": "List of HTTP request steps to execute"
        },
        "expected_behavior": {
          "type": "string",
          "required": true,
          "description": "Description of expected secure behavior"
        },
        "test_type": {
          "type": "string",
          "required": false,
          "description": "Type of test: 'sequence_bypass', 'state_manipulation', 'business_rule_violation' (default: 'sequence_bypass')"
        }
      },
      "json_prompt_template": "{\"tool\": \"logic_tester.test_logic_flow\", \"args\": {\"flow_name\": \"<NAME>\", \"steps\": [], \"expected_behavior\": \"<BEHAVIOR>\"}}"
    },
    {
      "tool_name": "tool_installer.request_install_from_github",
      "binary_name": "python",
      "description": "Request installation of a tool from GitHub (requires human confirmation)",
      "intrusive": true,
      "category": "control",
      "args_schema": {
        "repo_url": {
          "type": "string",
          "required": true,
          "description": "GitHub repository URL (e.g., 'https://github.com/user/repo')"
        },
        "description": {
          "type": "string",
          "required": true,
          "description": "What this tool does and why it's needed"
        },
        "package_name": {
          "type": "string",
          "required": false,
          "description": "Optional package name if different from repo name"
        }
      },
      "json_prompt_template": "{\"tool\": \"tool_installer.request_install_from_github\", \"args\": {\"repo_url\": \"<URL>\", \"description\": \"<DESCRIPTION>\"}}"
    },
    {
      "tool_name": "capture_screenshot_som",
      "binary_name": "playwright",
      "description": "Capture screenshot with Set-of-Mark (SoM) visual grounding - overlays numbered badges on all clickable elements and returns element mapping for precise interaction",
      "intrusive": false,
      "category": "visual_reconnaissance",
      "args_schema": {
        "url": {
          "type": "string",
          "required": true,
          "description": "Target URL to capture with SoM tagging"
        },
        "full_page": {
          "type": "boolean",
          "required": false,
          "description": "Capture full scrollable page (default: false)"
        }
      },
      "json_prompt_template": "{\"tool\": \"capture_screenshot_som\", \"args\": {\"url\": \"<URL>\", \"full_page\": <FULL_PAGE>}}"
    },
    {
      "tool_name": "click_element_by_id",
      "binary_name": "playwright",
      "description": "Click a specific element using its SoM ID from a previous capture_screenshot_som call - enables precise UI interaction",
      "intrusive": true,
      "category": "visual_reconnaissance",
      "args_schema": {
        "url": {
          "type": "string",
          "required": true,
          "description": "Target URL (must match URL from capture_screenshot_som)"
        },
        "element_id": {
          "type": "integer",
          "required": true,
          "description": "Element ID from SoM mapping (numbered badge on screenshot)"
        }
      },
      "json_prompt_template": "{\"tool\": \"click_element_by_id\", \"args\": {\"url\": \"<URL>\", \"element_id\": <ELEMENT_ID>}}"
    },
    {
      "tool_name": "visual_screenshot",
      "binary_name": "playwright",
      "description": "Capture regular authenticated screenshot without SoM badges - useful for visual verification and documentation",
      "intrusive": false,
      "category": "visual_reconnaissance",
      "args_schema": {
        "url": {
          "type": "string",
          "required": true,
          "description": "Target URL to screenshot"
        },
        "full_page": {
          "type": "boolean",
          "required": false,
          "description": "Capture full scrollable page (default: false)"
        }
      },
      "json_prompt_template": "{\"tool\": \"visual_screenshot\", \"args\": {\"url\": \"<URL>\", \"full_page\": <FULL_PAGE>}}"
    },
    {
      "tool_name": "solve_crypto",
      "binary_name": "python",
      "description": "Auto-detect and solve cryptographic challenges (hashes, ciphers, encodings). Uses ciphey for auto-decryption and hashid for hash identification.",
      "intrusive": false,
      "category": "ctf_crypto",
      "args_schema": {
        "text_or_file": {
          "type": "string",
          "required": true,
          "description": "Ciphertext, hash, or path to file containing encrypted content"
        }
      },
      "json_prompt_template": "{\"tool\": \"solve_crypto\", \"args\": {\"text_or_file\": \"<CIPHER_TEXT>\"}}"
    },
    {
      "tool_name": "crack_hash",
      "binary_name": "python",
      "description": "Attempt to crack a hash using john the ripper with wordlists",
      "intrusive": false,
      "category": "ctf_crypto",
      "args_schema": {
        "hash_value": {
          "type": "string",
          "required": true,
          "description": "The hash to crack"
        },
        "hash_type": {
          "type": "string",
          "required": false,
          "description": "Type of hash (e.g., md5, sha256). Auto-detected if not provided."
        },
        "wordlist": {
          "type": "string",
          "required": false,
          "description": "Path to wordlist file (default: rockyou.txt)"
        }
      },
      "json_prompt_template": "{\"tool\": \"crack_hash\", \"args\": {\"hash_value\": \"<HASH>\", \"hash_type\": \"<TYPE>\"}}"
    },
    {
      "tool_name": "analyze_binary",
      "binary_name": "python",
      "description": "Comprehensive binary analysis: extract strings, entry points, sections, and basic disassembly. Uses strings, objdump, readelf, and radare2.",
      "intrusive": false,
      "category": "ctf_reverse",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the binary file to analyze"
        }
      },
      "json_prompt_template": "{\"tool\": \"analyze_binary\", \"args\": {\"filepath\": \"<FILE_PATH>\"}}"
    },
    {
      "tool_name": "disassemble_function",
      "binary_name": "python",
      "description": "Disassemble a specific function from a binary using objdump",
      "intrusive": false,
      "category": "ctf_reverse",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the binary file"
        },
        "function_name": {
          "type": "string",
          "required": false,
          "description": "Name of function to disassemble (default: main)"
        }
      },
      "json_prompt_template": "{\"tool\": \"disassemble_function\", \"args\": {\"filepath\": \"<FILE_PATH>\", \"function_name\": \"main\"}}"
    },
    {
      "tool_name": "analyze_file_artifacts",
      "binary_name": "python",
      "description": "Forensic analysis: extract metadata (EXIF), find embedded files (binwalk), detect steganography. For images, PDFs, and other file types.",
      "intrusive": false,
      "category": "ctf_forensics",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the file to analyze"
        }
      },
      "json_prompt_template": "{\"tool\": \"analyze_file_artifacts\", \"args\": {\"filepath\": \"<FILE_PATH>\"}}"
    },
    {
      "tool_name": "extract_embedded",
      "binary_name": "python",
      "description": "Extract embedded files from a container file using binwalk",
      "intrusive": false,
      "category": "ctf_forensics",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the file containing embedded data"
        },
        "output_dir": {
          "type": "string",
          "required": false,
          "description": "Directory to extract files to"
        }
      },
      "json_prompt_template": "{\"tool\": \"extract_embedded\", \"args\": {\"filepath\": \"<FILE_PATH>\"}}"
    },
    {
      "tool_name": "extract_steghide",
      "binary_name": "python",
      "description": "Extract hidden data from images using steghide (for JPEG/BMP files)",
      "intrusive": false,
      "category": "ctf_forensics",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the carrier image file"
        },
        "password": {
          "type": "string",
          "required": false,
          "description": "Passphrase for extraction (empty for no password)"
        }
      },
      "json_prompt_template": "{\"tool\": \"extract_steghide\", \"args\": {\"filepath\": \"<FILE_PATH>\", \"password\": \"\"}}"
    },
    {
      "tool_name": "check_binary_protections",
      "binary_name": "python",
      "description": "Check binary security protections: NX, Canary, PIE, RELRO status. Essential for binary exploitation (pwn) challenges.",
      "intrusive": false,
      "category": "ctf_pwn",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the binary file"
        }
      },
      "json_prompt_template": "{\"tool\": \"check_binary_protections\", \"args\": {\"filepath\": \"<FILE_PATH>\"}}"
    },
    {
      "tool_name": "find_rop_gadgets",
      "binary_name": "python",
      "description": "Find ROP gadgets in a binary for exploitation. Uses pwntools if available.",
      "intrusive": false,
      "category": "ctf_pwn",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the binary file"
        },
        "max_gadgets": {
          "type": "integer",
          "required": false,
          "description": "Maximum number of gadgets to return (default: 50)"
        }
      },
      "json_prompt_template": "{\"tool\": \"find_rop_gadgets\", \"args\": {\"filepath\": \"<FILE_PATH>\"}}"
    },
    {
      "tool_name": "analyze_pcap",
      "binary_name": "python",
      "description": "Analyze PCAP network capture: extract credentials, HTTP streams, DNS queries, and suspicious flows. Uses tshark.",
      "intrusive": false,
      "category": "ctf_network",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the PCAP file"
        }
      },
      "json_prompt_template": "{\"tool\": \"analyze_pcap\", \"args\": {\"filepath\": \"<FILE_PATH>\"}}"
    },
    {
      "tool_name": "follow_tcp_stream",
      "binary_name": "python",
      "description": "Follow and extract a specific TCP stream from a PCAP file",
      "intrusive": false,
      "category": "ctf_network",
      "args_schema": {
        "filepath": {
          "type": "string",
          "required": true,
          "description": "Path to the PCAP file"
        },
        "stream_number": {
          "type": "integer",
          "required": false,
          "description": "TCP stream number to follow (default: 0)"
        }
      },
      "json_prompt_template": "{\"tool\": \"follow_tcp_stream\", \"args\": {\"filepath\": \"<FILE_PATH>\", \"stream_number\": 0}}"
    },
    {
      "tool_name": "hybrid_analysis",
      "binary_name": "python",
      "description": "Hybrid Analysis (Code-to-Payload Loop): Detect source code exposure (.git, package.json, etc.), auto-clone repositories, analyze code with LLM to identify exact vulnerable lines, and generate targeted payloads. Essential for white-box advantages on black-box targets.",
      "intrusive": false,
      "category": "sota_analysis",
      "priority": 1,
      "use_case": "Web applications with potential source code exposure",
      "args_schema": {
        "target_url": {
          "type": "string",
          "required": true,
          "description": "Target URL to analyze for source code exposure"
        }
      },
      "json_prompt_template": "{\"tool\": \"hybrid_analysis\", \"args\": {\"target_url\": \"<TARGET_URL>\"}}"
    },
    {
      "tool_name": "get_hive_intelligence",
      "binary_name": "internal",
      "description": "Get shared intelligence from Hive Mind for a target domain. Returns WAF bypasses discovered by other agents, known vulnerabilities, and failed attempts to avoid. Use this before attacking any domain to leverage swarm knowledge.",
      "intrusive": false,
      "category": "sota_analysis",
      "priority": 1,
      "use_case": "Before attacking any target domain",
      "args_schema": {
        "target_domain": {
          "type": "string",
          "required": true,
          "description": "Target domain to get intelligence for"
        }
      },
      "json_prompt_template": "{\"tool\": \"get_hive_intelligence\", \"args\": {\"target_domain\": \"<DOMAIN>\"}}"
    },
    {
      "tool_name": "share_waf_bypass",
      "binary_name": "internal",
      "description": "Share a discovered WAF bypass with the Hive Mind. When you find a bypass on one subdomain, all agents attacking related subdomains will instantly know and can apply the same technique.",
      "intrusive": false,
      "category": "sota_analysis",
      "priority": 1,
      "use_case": "After discovering a WAF bypass technique",
      "args_schema": {
        "target_domain": {
          "type": "string",
          "required": true,
          "description": "Domain where bypass was found"
        },
        "waf_type": {
          "type": "string",
          "required": true,
          "description": "Type of WAF (cloudflare, akamai, imperva, etc.)"
        },
        "bypass_technique": {
          "type": "string",
          "required": true,
          "description": "Description of the bypass technique"
        },
        "payload": {
          "type": "string",
          "required": true,
          "description": "The actual bypass payload"
        },
        "headers": {
          "type": "object",
          "required": false,
          "description": "Optional special headers used for bypass"
        }
      },
      "json_prompt_template": "{\"tool\": \"share_waf_bypass\", \"args\": {\"target_domain\": \"<DOMAIN>\", \"waf_type\": \"<WAF>\", \"bypass_technique\": \"<TECHNIQUE>\", \"payload\": \"<PAYLOAD>\"}}"
    },
    {
      "tool_name": "ingest_documentation",
      "binary_name": "internal",
      "description": "Ingest documentation (API docs, user manuals, policies) into the Semantic Auditor's RAG system. Extracts business policies like 'One coupon per user' for logic bug detection.",
      "intrusive": false,
      "category": "sota_analysis",
      "priority": 1,
      "use_case": "When target has accessible documentation",
      "args_schema": {
        "url": {
          "type": "string",
          "required": true,
          "description": "URL of the documentation to ingest"
        },
        "doc_type": {
          "type": "string",
          "required": false,
          "description": "Type of documentation: api_doc, user_manual, policy, faq (default: api_doc)"
        }
      },
      "json_prompt_template": "{\"tool\": \"ingest_documentation\", \"args\": {\"url\": \"<DOC_URL>\", \"doc_type\": \"api_doc\"}}"
    },
    {
      "tool_name": "audit_business_logic",
      "binary_name": "internal",
      "description": "Audit an action against business policies to detect logic bugs. Compares 'intended behavior' from ingested docs vs 'actual behavior' observed. Flags violations like using multiple coupons when docs say 'one per user'.",
      "intrusive": false,
      "category": "sota_analysis",
      "priority": 1,
      "use_case": "After performing actions that might violate business rules",
      "args_schema": {
        "action": {
          "type": "string",
          "required": true,
          "description": "Action performed (e.g., 'apply_coupon', 'create_order')"
        },
        "endpoint": {
          "type": "string",
          "required": true,
          "description": "API endpoint used"
        },
        "parameters": {
          "type": "object",
          "required": true,
          "description": "Request parameters"
        },
        "response": {
          "type": "object",
          "required": true,
          "description": "Response data"
        },
        "success": {
          "type": "boolean",
          "required": true,
          "description": "Whether the action succeeded"
        }
      },
      "json_prompt_template": "{\"tool\": \"audit_business_logic\", \"args\": {\"action\": \"<ACTION>\", \"endpoint\": \"<ENDPOINT>\", \"parameters\": {}, \"response\": {}, \"success\": true}}"
    }
  ]
}

"""
Binary Exploitation (Pwn) Module for Aegis v8.0

Provides binary exploitation capabilities including:
- Binary protection analysis (NX, Canary, PIE, RELRO)
- Basic exploit template generation
- ROP gadget finding

Tools wrapped: checksec, pwntools (Python library)
"""

import asyncio
import logging
import subprocess
import shutil
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path

logger = logging.getLogger(__name__)


class PwnExploiter:
    """
    Binary exploitation analysis engine for CTF and penetration testing.
    
    Wraps checksec and pwntools capabilities with self-healing.
    """
    
    # Dependency mapping: command -> package name
    DEPENDENCIES = {
        "checksec": "checksec",
        "file": "file",
        "readelf": "binutils",
        "objdump": "binutils",
    }
    
    # pwntools is a Python library, checked separately
    PYTHON_DEPENDENCIES = {
        "pwn": "pwntools",
    }
    
    def __init__(self):
        """Initialize the pwn exploiter."""
        self.tool_paths: Dict[str, Optional[str]] = {}
        self.python_libs_available: Dict[str, bool] = {}
        self._discover_tools()
        self._check_python_libs()
        
        # Configuration for safe command execution (prevent output bombs)
        self.max_output_bytes = 5 * 1024 * 1024  # 5MB default
        self.objdump_max_output_bytes = 10 * 1024 * 1024  # 10MB for objdump (larger disassembly)
        self.read_chunk_size = 4096  # 4KB chunks
        
        logger.info("ðŸ’€ PwnExploiter initialized")
    
    def _discover_tools(self) -> None:
        """Discover available pwn tools."""
        for tool in self.DEPENDENCIES.keys():
            path = shutil.which(tool)
            self.tool_paths[tool] = path
            if path:
                logger.debug(f"âœ… Found {tool}: {path}")
            else:
                logger.debug(f"âš ï¸ Tool {tool} not found")
    
    def _check_python_libs(self) -> None:
        """Check for Python library dependencies."""
        for lib in self.PYTHON_DEPENDENCIES.keys():
            try:
                __import__(lib)
                self.python_libs_available[lib] = True
                logger.debug(f"âœ… Python library {lib} available")
            except ImportError:
                self.python_libs_available[lib] = False
                logger.debug(f"âš ï¸ Python library {lib} not available")
    
    def check_dependency(self, tool_name: str) -> bool:
        """
        Check if a specific tool is available.
        
        Args:
            tool_name: Name of the tool to check
            
        Returns:
            True if the tool is available, False otherwise
        """
        # Check CLI tools
        if tool_name in self.tool_paths:
            return self.tool_paths.get(tool_name) is not None
        # Check Python libs
        if tool_name in self.python_libs_available:
            return self.python_libs_available.get(tool_name, False)
        return False
    
    def get_missing_dependencies(self) -> List[str]:
        """
        Get list of missing tools.
        
        Returns:
            List of tool names that are not installed
        """
        missing = []
        for tool, path in self.tool_paths.items():
            if path is None:
                missing.append(tool)
        for lib, available in self.python_libs_available.items():
            if not available:
                missing.append(f"python:{lib}")
        return missing
    
    async def _safe_run_command(
        self,
        cmd: List[str],
        timeout: int,
        max_bytes: Optional[int] = None
    ) -> Tuple[bytes, bytes, int]:
        """
        Safely run a command with output size limits to prevent "output bombs".
        
        Instead of using communicate() which loads all output into RAM,
        this reads the output in chunks and enforces a maximum size limit.
        
        Args:
            cmd: Command and arguments as a list
            timeout: Maximum time to wait for command completion
            max_bytes: Maximum bytes to read from stdout/stderr combined.
                      If None, uses self.max_output_bytes (default 5MB)
        
        Returns:
            Tuple of (stdout_bytes, stderr_bytes, return_code)
            
        Raises:
            RuntimeError: If output exceeds max_bytes
            asyncio.TimeoutError: If command exceeds timeout
        """
        if max_bytes is None:
            max_bytes = self.max_output_bytes
        
        # Create subprocess
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout_chunks = []
        stderr_chunks = []
        total_bytes_read = 0
        
        try:
            # Read output in chunks with size tracking
            async def read_stream(stream, chunks_list):
                nonlocal total_bytes_read
                while True:
                    try:
                        chunk = await asyncio.wait_for(
                            stream.read(self.read_chunk_size),
                            timeout=1.0  # Short timeout per chunk
                        )
                        if not chunk:
                            break
                        
                        chunk_size = len(chunk)
                        total_bytes_read += chunk_size
                        
                        # Check if we've exceeded the limit
                        if total_bytes_read > max_bytes:
                            # Kill the process immediately
                            try:
                                process.kill()
                                await process.wait()
                            except ProcessLookupError:
                                # Process already terminated
                                pass
                            except Exception as e:
                                logger.warning(f"Error killing process after size limit exceeded: {e}")
                            
                            raise RuntimeError(
                                f"Output exceeded maximum allowed size ({max_bytes} bytes). "
                                f"Process killed to prevent memory exhaustion. "
                                f"This may indicate an 'output bomb' attack."
                            )
                        
                        chunks_list.append(chunk)
                    except asyncio.TimeoutError:
                        # No data available right now, check if process finished
                        if process.returncode is not None:
                            break
                        continue
            
            # Read both streams concurrently
            await asyncio.wait_for(
                asyncio.gather(
                    read_stream(process.stdout, stdout_chunks),
                    read_stream(process.stderr, stderr_chunks)
                ),
                timeout=timeout
            )
            
            # Wait for process to complete
            await asyncio.wait_for(process.wait(), timeout=5.0)
            
        except asyncio.TimeoutError:
            # Kill process on timeout
            try:
                process.kill()
                await process.wait()
            except ProcessLookupError:
                # Process already terminated
                pass
            except Exception as e:
                logger.warning(f"Error killing process after timeout: {e}")
            raise asyncio.TimeoutError(f"Command timed out after {timeout} seconds")
        
        # Combine chunks
        stdout_bytes = b''.join(stdout_chunks)
        stderr_bytes = b''.join(stderr_chunks)
        return_code = process.returncode if process.returncode is not None else -1
        
        return stdout_bytes, stderr_bytes, return_code
    
    async def check_binary_protections(
        self,
        filepath: str,
        timeout: int = 30
    ) -> Dict[str, Any]:
        """
        Check binary security protections.
        
        Reports:
        - NX (No-Execute / DEP)
        - Stack Canary
        - PIE (Position Independent Executable)
        - RELRO (Relocation Read-Only)
        - Fortify Source
        
        Args:
            filepath: Path to the binary file
            timeout: Maximum time for analysis
            
        Returns:
            Dictionary with protection status
        """
        logger.info(f"ðŸ›¡ï¸ Checking binary protections: {filepath}")
        
        path = Path(filepath)
        if not path.exists():
            return {"status": "error", "error": f"File not found: {filepath}"}
        
        if not path.is_file():
            return {"status": "error", "error": f"Not a file: {filepath}"}
        
        results = {
            "status": "success",
            "filepath": str(path.absolute()),
            "filename": path.name,
            "protections": {
                "nx": None,
                "canary": None,
                "pie": None,
                "relro": None,
                "fortify": None,
            },
            "architecture": None,
            "tools_used": [],
        }
        
        # Try checksec first (most comprehensive)
        checksec_result = await self._run_checksec(filepath, timeout)
        if checksec_result.get("status") == "success":
            results["protections"] = checksec_result.get("protections", {})
            results["tools_used"].append("checksec")
        
        # Get architecture info
        arch_result = await self._get_architecture(filepath, timeout)
        if arch_result.get("status") == "success":
            results["architecture"] = arch_result.get("data")
            results["tools_used"].append("file")
        
        # If checksec failed, try manual analysis
        if not results["tools_used"] or results["protections"]["nx"] is None:
            manual_result = await self._manual_protection_check(filepath, timeout)
            if manual_result.get("status") == "success":
                # Merge manual results
                for key, value in manual_result.get("protections", {}).items():
                    if results["protections"].get(key) is None:
                        results["protections"][key] = value
                if "readelf" not in results["tools_used"]:
                    results["tools_used"].append("readelf")
        
        # Generate security assessment
        results["assessment"] = self._assess_exploitability(results["protections"])
        
        return results
    
    async def _run_checksec(
        self,
        filepath: str,
        timeout: int = 30
    ) -> Dict[str, Any]:
        """Run checksec on a binary."""
        if not self.check_dependency("checksec"):
            return {"status": "skipped", "error": "checksec not available"}
        
        try:
            cmd = ["checksec", "--file=" + filepath]
            
            # Use safe command runner to prevent output bombs
            stdout, stderr, _ = await self._safe_run_command(cmd, timeout)
            
            output = stdout.decode('utf-8', errors='replace')
            output += stderr.decode('utf-8', errors='replace')
            
            # Parse checksec output
            protections = {
                "nx": None,
                "canary": None,
                "pie": None,
                "relro": None,
                "fortify": None,
            }
            
            output_lower = output.lower()
            
            # Check NX
            if 'nx enabled' in output_lower:
                protections["nx"] = True
            elif 'nx disabled' in output_lower or 'no nx' in output_lower:
                protections["nx"] = False
            
            # Check Canary
            if 'canary found' in output_lower:
                protections["canary"] = True
            elif 'no canary' in output_lower:
                protections["canary"] = False
            
            # Check PIE
            if 'pie enabled' in output_lower:
                protections["pie"] = True
            elif 'no pie' in output_lower:
                protections["pie"] = False
            
            # Check RELRO
            if 'full relro' in output_lower:
                protections["relro"] = "full"
            elif 'partial relro' in output_lower:
                protections["relro"] = "partial"
            elif 'no relro' in output_lower:
                protections["relro"] = "none"
            
            # Check Fortify
            if 'fortify' in output_lower:
                if 'yes' in output_lower or 'enabled' in output_lower:
                    protections["fortify"] = True
                else:
                    protections["fortify"] = False
            
            return {
                "status": "success",
                "protections": protections,
                "raw_output": output
            }
            
        except asyncio.TimeoutError:
            return {"status": "error", "error": "checksec timed out"}
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    async def _get_architecture(
        self,
        filepath: str,
        timeout: int = 10
    ) -> Dict[str, Any]:
        """Get binary architecture info."""
        if not self.check_dependency("file"):
            return {"status": "skipped", "error": "file command not available"}
        
        try:
            cmd = ["file", filepath]
            
            # Use safe command runner to prevent output bombs
            stdout, _, _ = await self._safe_run_command(cmd, timeout)
            
            output = stdout.decode('utf-8', errors='replace').strip()
            
            # Parse architecture
            arch_info = {
                "raw": output,
                "bits": None,
                "arch": None,
                "type": None,
            }
            
            if "64-bit" in output:
                arch_info["bits"] = 64
            elif "32-bit" in output:
                arch_info["bits"] = 32
            
            if "x86-64" in output or "x86_64" in output:
                arch_info["arch"] = "x86_64"
            elif "x86" in output or "i386" in output or "i686" in output:
                arch_info["arch"] = "x86"
            elif "ARM" in output:
                arch_info["arch"] = "ARM"
            elif "MIPS" in output:
                arch_info["arch"] = "MIPS"
            
            if "ELF" in output:
                arch_info["type"] = "ELF"
            elif "PE32" in output:
                arch_info["type"] = "PE"
            elif "Mach-O" in output:
                arch_info["type"] = "Mach-O"
            
            return {
                "status": "success",
                "data": arch_info
            }
            
        except asyncio.TimeoutError:
            return {"status": "error", "error": "Architecture detection timed out"}
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    async def _manual_protection_check(
        self,
        filepath: str,
        timeout: int = 30
    ) -> Dict[str, Any]:
        """Manual protection check using readelf."""
        if not self.check_dependency("readelf"):
            return {"status": "skipped", "error": "readelf not available"}
        
        protections = {
            "nx": None,
            "canary": None,
            "pie": None,
            "relro": None,
            "fortify": None,
        }
        
        try:
            # Check for stack canary
            cmd = ["readelf", "-s", filepath]
            stdout, _, _ = await self._safe_run_command(cmd, timeout)
            output = stdout.decode('utf-8', errors='replace')
            
            if '__stack_chk_fail' in output:
                protections["canary"] = True
            else:
                protections["canary"] = False
            
            # Check for PIE
            cmd = ["readelf", "-h", filepath]
            stdout, _, _ = await self._safe_run_command(cmd, timeout)
            output = stdout.decode('utf-8', errors='replace')
            
            if 'DYN' in output:
                protections["pie"] = True
            elif 'EXEC' in output:
                protections["pie"] = False
            
            # Check RELRO
            cmd = ["readelf", "-l", filepath]
            stdout, _, _ = await self._safe_run_command(cmd, timeout)
            output = stdout.decode('utf-8', errors='replace')
            
            if 'GNU_RELRO' in output:
                # Check for BIND_NOW for full RELRO
                cmd = ["readelf", "-d", filepath]
                stdout, _, _ = await self._safe_run_command(cmd, timeout)
                dyn_output = stdout.decode('utf-8', errors='replace')
                
                if 'BIND_NOW' in dyn_output:
                    protections["relro"] = "full"
                else:
                    protections["relro"] = "partial"
            else:
                protections["relro"] = "none"
            
            # Check NX via GNU_STACK
            if 'GNU_STACK' in output:
                # Check if executable
                for line in output.split('\n'):
                    if 'GNU_STACK' in line:
                        if 'RWE' in line or 'E' in line.split()[-1]:
                            protections["nx"] = False
                        else:
                            protections["nx"] = True
                        break
            
            return {
                "status": "success",
                "protections": protections
            }
            
        except asyncio.TimeoutError:
            return {"status": "error", "error": "Manual protection check timed out"}
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def _assess_exploitability(self, protections: Dict[str, Any]) -> Dict[str, Any]:
        """Assess exploitability based on protections."""
        assessment = {
            "difficulty": "unknown",
            "vulnerabilities": [],
            "recommendations": [],
        }
        
        score = 0  # Higher = more protected
        
        if protections.get("nx") is True:
            score += 2
        elif protections.get("nx") is False:
            assessment["vulnerabilities"].append("NX disabled - stack/heap execution possible")
        
        if protections.get("canary") is True:
            score += 2
        elif protections.get("canary") is False:
            assessment["vulnerabilities"].append("No stack canary - buffer overflow easier")
        
        if protections.get("pie") is True:
            score += 2
        elif protections.get("pie") is False:
            assessment["vulnerabilities"].append("No PIE - fixed addresses, no ASLR bypass needed")
        
        if protections.get("relro") == "full":
            score += 2
        elif protections.get("relro") == "partial":
            score += 1
            assessment["vulnerabilities"].append("Partial RELRO - GOT overwrite may be possible")
        elif protections.get("relro") == "none":
            assessment["vulnerabilities"].append("No RELRO - GOT freely writable")
        
        # Determine difficulty
        if score <= 2:
            assessment["difficulty"] = "easy"
            assessment["recommendations"].append("Multiple protections disabled - focus on basic overflow")
        elif score <= 4:
            assessment["difficulty"] = "medium"
            assessment["recommendations"].append("Some protections enabled - may need ROP or leak")
        elif score <= 6:
            assessment["difficulty"] = "hard"
            assessment["recommendations"].append("Most protections enabled - need info leak + ROP")
        else:
            assessment["difficulty"] = "very_hard"
            assessment["recommendations"].append("All protections enabled - complex exploit needed")
        
        return assessment
    
    async def find_rop_gadgets(
        self,
        filepath: str,
        max_gadgets: int = 50,
        timeout: int = 120
    ) -> Dict[str, Any]:
        """
        Find ROP gadgets in a binary.
        
        Uses pwntools if available, otherwise falls back to basic search.
        
        Args:
            filepath: Path to the binary
            max_gadgets: Maximum number of gadgets to return
            timeout: Maximum time for gadget search
            
        Returns:
            Dictionary with ROP gadgets
        """
        logger.info(f"ðŸ” Finding ROP gadgets: {filepath}")
        
        path = Path(filepath)
        if not path.exists():
            return {"status": "error", "error": f"File not found: {filepath}"}
        
        # Try pwntools first
        if self.check_dependency("pwn"):
            try:
                import pwn
                pwn.context.log_level = 'error'  # Suppress pwntools output
                
                elf = pwn.ELF(filepath)
                rop = pwn.ROP(elf)
                
                # Get useful gadgets
                gadgets = []
                
                # Common useful gadgets
                useful_patterns = [
                    'pop rdi', 'pop rsi', 'pop rdx', 'pop rcx',
                    'pop rax', 'pop rbx', 'pop rbp', 'pop rsp',
                    'ret', 'leave', 'syscall', 'int 0x80',
                    'call rax', 'jmp rax',
                ]
                
                # Search for gadgets
                for pattern in useful_patterns:
                    try:
                        gadget = rop.find_gadget([pattern.split()[0]])
                        if gadget:
                            gadgets.append({
                                "address": hex(gadget[0]),
                                "instructions": pattern,
                            })
                    except Exception:
                        continue
                
                return {
                    "status": "success",
                    "data": {
                        "gadgets": gadgets[:max_gadgets],
                        "count": len(gadgets),
                        "tool": "pwntools"
                    }
                }
                
            except Exception as e:
                logger.warning(f"pwntools ROP search failed: {e}")
        
        # Fallback: basic search with objdump
        return await self._basic_gadget_search(filepath, max_gadgets, timeout)
    
    async def _basic_gadget_search(
        self,
        filepath: str,
        max_gadgets: int,
        timeout: int
    ) -> Dict[str, Any]:
        """Basic ROP gadget search using objdump."""
        if not self.check_dependency("objdump"):
            return {"status": "error", "error": "Neither pwntools nor objdump available"}
        
        try:
            cmd = ["objdump", "-d", filepath]
            
            # Use safe command runner to prevent output bombs
            # objdump can produce very large output for big binaries
            stdout, _, _ = await self._safe_run_command(cmd, timeout, max_bytes=self.objdump_max_output_bytes)
            
            output = stdout.decode('utf-8', errors='replace')
            
            # Search for ret instructions and nearby pops
            gadgets = []
            lines = output.split('\n')
            
            for i, line in enumerate(lines):
                if 'ret' in line.lower():
                    # Get address
                    parts = line.split(':')
                    if len(parts) >= 2:
                        addr = parts[0].strip()
                        # Look at previous lines for pop instructions
                        instructions = []
                        for j in range(max(0, i-3), i+1):
                            if j < len(lines) and ':' in lines[j]:
                                instr = lines[j].split('\t')
                                if len(instr) >= 3:
                                    instructions.append(instr[-1].strip())
                        
                        if instructions:
                            gadgets.append({
                                "address": addr,
                                "instructions": ' ; '.join(instructions)
                            })
                            
                            if len(gadgets) >= max_gadgets:
                                break
            
            return {
                "status": "success",
                "data": {
                    "gadgets": gadgets,
                    "count": len(gadgets),
                    "tool": "objdump (basic search)"
                }
            }
            
        except asyncio.TimeoutError:
            return {"status": "error", "error": "Gadget search timed out"}
        except Exception as e:
            return {"status": "error", "error": str(e)}


# Singleton instance
_pwn_exploiter_instance = None


def get_pwn_exploiter() -> PwnExploiter:
    """Get singleton pwn exploiter instance."""
    global _pwn_exploiter_instance
    if _pwn_exploiter_instance is None:
        _pwn_exploiter_instance = PwnExploiter()
    return _pwn_exploiter_instance
